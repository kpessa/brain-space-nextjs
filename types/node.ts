// Flexible Node type definition with optional fields and aliasing support

import type { RecurringCompletion, TaskType } from './recurrence'

export type LogicType = 'AND' | 'OR'

export interface Attempt {
  id: string
  description: string
  timestamp: string // ISO date
}

export type RelativeUnit = 'minutes' | 'hours' | 'days' | 'weeks' | 'months'

export type DueDate =
  | { type: 'exact'; date: string } // ISO date string
  | { type: 'relative'; offset: number; unit: RelativeUnit } // e.g., 3 days from now

export interface Recurrence {
  frequency: 'daily' | 'weekly' | 'monthly' | 'custom'
  timesPerInterval?: number // e.g., 2 times per day or 4 times per week
  timesOfDay?: string[] // e.g., ["08:00", "18:00"]
  daysOfWeek?: (
    | 'Monday'
    | 'Tuesday'
    | 'Wednesday'
    | 'Thursday'
    | 'Friday'
    | 'Saturday'
    | 'Sunday'
  )[] // for weekly
  interval?: number // for custom intervals
  unit?: RelativeUnit // used with interval if frequency is "custom"
  repeatCount?: number // optional, how many times to repeat
  endDate?: string // optional ISO date for when recurrence should stop
}

export type NodeType = "goal" | "project" | "task" | "option" | "idea" | "question" | "problem" | "insight" | "thought" | "concern";

// AI-focused input type for GenAI - excludes system-managed fields
export type GenAiNodeInput = {
  title?: string
  description?: string
  aliases?: string[]
  type?: NodeType
  tags?: string[]
  urgency?: number
  importance?: number
  priority?: number // optional: can be computed later
  children?: string[] // references by title
  logicType?: LogicType
  attempts?: Omit<Attempt, 'id'>[] // id can be generated by system
  dueDate?: DueDate
  recurrence?: Recurrence
  completed?: boolean
}

export interface Node {
  id: string
  userId: string // Foreign key to user
  generatedById?: string // Optional foreign key to route or page where node was generated
  lastUpdatedBy?: string // Optional foreign key to user who last updated the node

  title?: string
  description?: string

  // Aliases (optional)
  aliases?: string[]

  // Node classification (optional)
  type?: NodeType
  tags?: string[]

  // Eisenhower matrix (optional)
  urgency?: number
  importance?: number
  priority?: number // computed from urgency + importance

  // ReactFlow-related data (optional)
  reactFlow?: {
    position?: {
      x: number
      y: number
    }
    size?: {
      width: number
      height: number
    }
  }

  // Children logic (optional)
  children?: string[]
  logicType?: LogicType

  // Attempts (optional)
  attempts?: Attempt[]

  // Due date (optional)
  dueDate?: DueDate

  // Recurrence (optional)
  recurrence?: Recurrence

  // Metadata (optional)
  completed?: boolean
  completedAt?: string
  createdAt?: string
  updatedAt?: string

  // Recurring task fields (optional)
  taskType?: TaskType
  recurringCompletions?: RecurringCompletion[]
  currentStreak?: number
  longestStreak?: number
  lastRecurringCompletionDate?: string
}

// Helper functions for node operations
export function getNodeTypeColor(type?: NodeType): string {
  const colors: Record<NodeType, string> = {
    goal: 'text-purple-600',
    project: 'text-blue-600',
    task: 'text-green-600',
    option: 'text-yellow-600',
    idea: 'text-pink-600',
    question: 'text-indigo-600',
    problem: 'text-red-600',
    insight: 'text-teal-600',
    thought: 'text-gray-600',
    concern: 'text-orange-600',
  }
  return type ? colors[type] : 'text-gray-600'
}

export function getNodeTypeIcon(type?: NodeType): string {
  const icons: Record<NodeType, string> = {
    goal: '🎯',
    project: '📁',
    task: '✅',
    option: '🤔',
    idea: '💡',
    question: '❓',
    problem: '⚠️',
    insight: '✨',
    thought: '💭',
    concern: '😟',
  }
  return type ? icons[type] : '📝'
}

export function getNodePriority(urgency?: number, importance?: number): number {
  if (!urgency || !importance) return 0
  return urgency + importance
}

export function getEisenhowerQuadrant(urgency?: number, importance?: number): string {
  if (!urgency || !importance) return 'not-set'
  
  if (urgency >= 5 && importance >= 5) return 'do-first'
  if (urgency < 5 && importance >= 5) return 'schedule'
  if (urgency >= 5 && importance < 5) return 'delegate'
  return 'eliminate'
}